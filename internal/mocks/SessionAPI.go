// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	channel "perun.network/go-perun/channel"

	mock "github.com/stretchr/testify/mock"

	perun "github.com/hyperledger-labs/perun-node"

	wallet "perun.network/go-perun/wallet"

	watcher "perun.network/go-perun/watcher"
)

// SessionAPI is an autogenerated mock type for the SessionAPI type
type SessionAPI struct {
	mock.Mock
}

// AddPeerID provides a mock function with given fields: _a0
func (_m *SessionAPI) AddPeerID(_a0 perun.PeerID) perun.APIError {
	ret := _m.Called(_a0)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(perun.PeerID) perun.APIError); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// Close provides a mock function with given fields: force
func (_m *SessionAPI) Close(force bool) ([]perun.ChInfo, perun.APIError) {
	ret := _m.Called(force)

	var r0 []perun.ChInfo
	if rf, ok := ret.Get(0).(func(bool) []perun.ChInfo); ok {
		r0 = rf(force)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]perun.ChInfo)
		}
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(bool) perun.APIError); ok {
		r1 = rf(force)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// DeployAssetERC20 provides a mock function with given fields: tokenERC20
func (_m *SessionAPI) DeployAssetERC20(tokenERC20 string) (string, perun.APIError) {
	ret := _m.Called(tokenERC20)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(tokenERC20)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(string) perun.APIError); ok {
		r1 = rf(tokenERC20)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// Fund provides a mock function with given fields: ctx, req
func (_m *SessionAPI) Fund(ctx context.Context, req channel.FundingReq) error {
	ret := _m.Called(ctx, req)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, channel.FundingReq) error); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCh provides a mock function with given fields: _a0
func (_m *SessionAPI) GetCh(_a0 string) (perun.ChAPI, perun.APIError) {
	ret := _m.Called(_a0)

	var r0 perun.ChAPI
	if rf, ok := ret.Get(0).(func(string) perun.ChAPI); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.ChAPI)
		}
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(string) perun.APIError); ok {
		r1 = rf(_a0)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// GetChsInfo provides a mock function with given fields:
func (_m *SessionAPI) GetChsInfo() []perun.ChInfo {
	ret := _m.Called()

	var r0 []perun.ChInfo
	if rf, ok := ret.Get(0).(func() []perun.ChInfo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]perun.ChInfo)
		}
	}

	return r0
}

// GetPeerID provides a mock function with given fields: alias
func (_m *SessionAPI) GetPeerID(alias string) (perun.PeerID, perun.APIError) {
	ret := _m.Called(alias)

	var r0 perun.PeerID
	if rf, ok := ret.Get(0).(func(string) perun.PeerID); ok {
		r0 = rf(alias)
	} else {
		r0 = ret.Get(0).(perun.PeerID)
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(string) perun.APIError); ok {
		r1 = rf(alias)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// ID provides a mock function with given fields:
func (_m *SessionAPI) ID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// IsAssetRegistered provides a mock function with given fields: asset
func (_m *SessionAPI) IsAssetRegistered(asset channel.Asset) bool {
	ret := _m.Called(asset)

	var r0 bool
	if rf, ok := ret.Get(0).(func(channel.Asset) bool); ok {
		r0 = rf(asset)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OpenCh provides a mock function with given fields: _a0, _a1, _a2, _a3
func (_m *SessionAPI) OpenCh(_a0 context.Context, _a1 perun.BalInfo, _a2 perun.App, _a3 uint64) (perun.ChInfo, perun.APIError) {
	ret := _m.Called(_a0, _a1, _a2, _a3)

	var r0 perun.ChInfo
	if rf, ok := ret.Get(0).(func(context.Context, perun.BalInfo, perun.App, uint64) perun.ChInfo); ok {
		r0 = rf(_a0, _a1, _a2, _a3)
	} else {
		r0 = ret.Get(0).(perun.ChInfo)
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(context.Context, perun.BalInfo, perun.App, uint64) perun.APIError); ok {
		r1 = rf(_a0, _a1, _a2, _a3)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// Progress provides a mock function with given fields: _a0, _a1
func (_m *SessionAPI) Progress(_a0 context.Context, _a1 perun.ProgressReq) perun.APIError {
	ret := _m.Called(_a0, _a1)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(context.Context, perun.ProgressReq) perun.APIError); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// Register provides a mock function with given fields: _a0, _a1, _a2
func (_m *SessionAPI) Register(_a0 context.Context, _a1 perun.AdjudicatorReq, _a2 []channel.SignedState) perun.APIError {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(context.Context, perun.AdjudicatorReq, []channel.SignedState) perun.APIError); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// RegisterAssetERC20 provides a mock function with given fields: asset, token, acc
func (_m *SessionAPI) RegisterAssetERC20(asset channel.Asset, token wallet.Address, acc wallet.Address) bool {
	ret := _m.Called(asset, token, acc)

	var r0 bool
	if rf, ok := ret.Get(0).(func(channel.Asset, wallet.Address, wallet.Address) bool); ok {
		r0 = rf(asset, token, acc)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RespondChProposal provides a mock function with given fields: _a0, _a1, _a2
func (_m *SessionAPI) RespondChProposal(_a0 context.Context, _a1 string, _a2 bool) (perun.ChInfo, perun.APIError) {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 perun.ChInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) perun.ChInfo); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Get(0).(perun.ChInfo)
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(context.Context, string, bool) perun.APIError); ok {
		r1 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// StartWatchingLedgerChannel provides a mock function with given fields: _a0, _a1
func (_m *SessionAPI) StartWatchingLedgerChannel(_a0 context.Context, _a1 channel.SignedState) (watcher.StatesPub, watcher.AdjudicatorSub, perun.APIError) {
	ret := _m.Called(_a0, _a1)

	var r0 watcher.StatesPub
	if rf, ok := ret.Get(0).(func(context.Context, channel.SignedState) watcher.StatesPub); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(watcher.StatesPub)
		}
	}

	var r1 watcher.AdjudicatorSub
	if rf, ok := ret.Get(1).(func(context.Context, channel.SignedState) watcher.AdjudicatorSub); ok {
		r1 = rf(_a0, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(watcher.AdjudicatorSub)
		}
	}

	var r2 perun.APIError
	if rf, ok := ret.Get(2).(func(context.Context, channel.SignedState) perun.APIError); ok {
		r2 = rf(_a0, _a1)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(perun.APIError)
		}
	}

	return r0, r1, r2
}

// StartWatchingSubChannel provides a mock function with given fields: ctx, parent, signedState
func (_m *SessionAPI) StartWatchingSubChannel(ctx context.Context, parent [32]byte, signedState channel.SignedState) (watcher.StatesPub, watcher.AdjudicatorSub, perun.APIError) {
	ret := _m.Called(ctx, parent, signedState)

	var r0 watcher.StatesPub
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte, channel.SignedState) watcher.StatesPub); ok {
		r0 = rf(ctx, parent, signedState)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(watcher.StatesPub)
		}
	}

	var r1 watcher.AdjudicatorSub
	if rf, ok := ret.Get(1).(func(context.Context, [32]byte, channel.SignedState) watcher.AdjudicatorSub); ok {
		r1 = rf(ctx, parent, signedState)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(watcher.AdjudicatorSub)
		}
	}

	var r2 perun.APIError
	if rf, ok := ret.Get(2).(func(context.Context, [32]byte, channel.SignedState) perun.APIError); ok {
		r2 = rf(ctx, parent, signedState)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(perun.APIError)
		}
	}

	return r0, r1, r2
}

// StopWatching provides a mock function with given fields: _a0, _a1
func (_m *SessionAPI) StopWatching(_a0 context.Context, _a1 [32]byte) perun.APIError {
	ret := _m.Called(_a0, _a1)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) perun.APIError); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// SubChProposals provides a mock function with given fields: _a0
func (_m *SessionAPI) SubChProposals(_a0 perun.ChProposalNotifier) perun.APIError {
	ret := _m.Called(_a0)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(perun.ChProposalNotifier) perun.APIError); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// Subscribe provides a mock function with given fields: _a0, _a1
func (_m *SessionAPI) Subscribe(_a0 context.Context, _a1 [32]byte) (channel.AdjudicatorSubscription, perun.APIError) {
	ret := _m.Called(_a0, _a1)

	var r0 channel.AdjudicatorSubscription
	if rf, ok := ret.Get(0).(func(context.Context, [32]byte) channel.AdjudicatorSubscription); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(channel.AdjudicatorSubscription)
		}
	}

	var r1 perun.APIError
	if rf, ok := ret.Get(1).(func(context.Context, [32]byte) perun.APIError); ok {
		r1 = rf(_a0, _a1)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(perun.APIError)
		}
	}

	return r0, r1
}

// UnsubChProposals provides a mock function with given fields:
func (_m *SessionAPI) UnsubChProposals() perun.APIError {
	ret := _m.Called()

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func() perun.APIError); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

// Withdraw provides a mock function with given fields: _a0, _a1, _a2
func (_m *SessionAPI) Withdraw(_a0 context.Context, _a1 perun.AdjudicatorReq, _a2 channel.StateMap) perun.APIError {
	ret := _m.Called(_a0, _a1, _a2)

	var r0 perun.APIError
	if rf, ok := ret.Get(0).(func(context.Context, perun.AdjudicatorReq, channel.StateMap) perun.APIError); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(perun.APIError)
		}
	}

	return r0
}

type mockConstructorTestingTNewSessionAPI interface {
	mock.TestingT
	Cleanup(func())
}

// NewSessionAPI creates a new instance of SessionAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewSessionAPI(t mockConstructorTestingTNewSessionAPI) *SessionAPI {
	mock := &SessionAPI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
